<!DOCTYPE html>
<html>
<head>
<title>readme.MD</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E9%97%AE%E9%A2%988">问题8</h1>
<h2 id="1-%E4%BB%BB%E5%8A%A1%E7%AE%80%E4%BB%8B">1 任务简介</h2>
<p>您将使用面向对象的编程（类和继承）来构建一个程序来监视 Internet 上的新闻源。您的程序将过滤新闻，当用户注意到与该用户的兴趣相匹配的新闻故事时发出警报（例如，每当发布与bilibili有关的故事时，用户可能对通知感兴趣）。</p>
<p>Internet上的新闻源，是新闻的聚合体，通常简称RSS（Really Simple Syndication）。例如http://www.chinanews.com/rss/scroll-news.xml，会及时更新当天的即时新闻；其他类型的新闻，可以参考[2]。</p>
<p>我们可以每30分钟去网站上读取RSS的内容。RSS中的内容可能有差异，但多数包括如下的内容：</p>
<pre class="hljs"><code><div>-新闻标题
-新闻链接
-新闻描述
-新闻时间
</div></code></pre>
<p>在网页中，使用类似HTML的标签进行描述，例如</p>
<pre class="hljs"><code><div>&lt;item&gt;&lt;title&gt;桂林市漓江水库群三座水库开闸排洪&lt;/title&gt;&lt;link&gt;http://www.chinanews.com/sh/2020/06-08/9206720.shtml&lt;/link&gt;&lt;description&gt;中新网桂林6月8日电(刘建设 欧惠兰)记者从桂林市漓江水库群管理部门获悉，6月8日18时，桂林市漓江水库群斧子口、小溶江、川江三座水库再度开闸排洪，以腾出部分库容防御后续强降雨，为漓江拦洪削峰。&lt;/description&gt;&lt;pubDate&gt;2020-06-08 20:41:15&lt;/pubDate&gt;&lt;/item&gt;
</div></code></pre>
<p>大量的新闻被下载下来之后，一定要先进行过滤，只有满足特定条件的新闻才显示给用户看。过滤时针对每一条新闻，过滤的条件可以包括：</p>
<pre class="hljs"><code><div>-新闻标题:新闻标题中包含特定的关键字，关键字不区分大小写；
-新闻链接：不支持过滤
-新闻描述:新闻描述中包含特定的关键字，关键字不区分大小写；
-新闻时间：在指定时间点之前；或指定时间点之后；
</div></code></pre>
<p>例如，新闻标题中包含&quot;上海&quot;，新闻描述中包含&quot;夜市&quot;，新闻时间在&quot;2020/6/6 8:00&quot;之前等</p>
<p>为了得到有效的结果，我们还需要把过滤条件进行组合，即支持</p>
<pre class="hljs"><code><div>-not:把指定的过滤条件取反；
-or:可以把两个指定的条件进行或操作(or);
-and:可以把两个指定的条件进行与操作(and);
</div></code></pre>
<p>例如，新闻标题中包含&quot;上海&quot;且新闻描述中包含&quot;夜市&quot;。</p>
<h2 id="2-%E6%96%B0%E9%97%BB">2 新闻</h2>
<h3 id="21-%E6%96%B0%E9%97%BB%E7%9A%84%E8%A1%A8%E7%A4%BA">2.1 新闻的表示</h3>
<p>可以定义新闻类，包含属性：title_, link_, description_, pubdate_，以及guid_。引入guid_是为了对新闻进行唯一的标识，类似于身份证的功能。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsStory</span>
{</span>
<span class="hljs-keyword">public</span>:
    ...
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> guid_;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> title_;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> link_;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> description_;
    <span class="hljs-built_in">std</span>::chrono::system_clock::time_point pub_date_;
};
<span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> NewsStory &amp;story);
<span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(<span class="hljs-built_in">std</span>::istream &amp;is, NewsStory &amp;story);
</div></code></pre>
<h3 id="22-%E6%96%B0%E9%97%BB%E7%9A%84%E8%AF%BB%E5%8F%96">2.2 新闻的读取</h3>
<p>这一部分，使用了SFML的network功能和C++的re功能（Regular Expression, 正则表达式功能）。核心的代码也分为两个部分，分别是网络读取，然后是re处理。</p>
<pre class="hljs"><code><div><span class="hljs-function">NewsStories <span class="hljs-title">do_fetch</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; header, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; uri)</span>
</span>{
    <span class="hljs-comment">// 使用Http读取网络的内容</span>
    sf::Http http{header};
    sf::Http::Request request;
    request.setMethod(sf::Http::Request::Get);
    request.setUri(uri);
    request.setHttpVersion(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// HTTP 1.1</span>
    sf::Http::Response response = http.sendRequest(request);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> content=response.getBody();

    <span class="hljs-comment">// 使用re进行处理读取的文件</span>
    NewsStories stories;

    <span class="hljs-built_in">std</span>::regex pattern{<span class="hljs-string">"&lt;item&gt;&lt;title&gt;([\\s\\S]*?)&lt;/title&gt;&lt;link&gt;([\\s\\S]*?)&lt;/link&gt;&lt;description&gt;([\\s\\S]*?)&lt;/description&gt;&lt;pubDate&gt;([\\s\\S]*?)&lt;/pubDate&gt;&lt;/item&gt;"</span>};
    <span class="hljs-built_in">std</span>::smatch result;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::const_iterator start = content.<span class="hljs-built_in">begin</span>();
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::const_iterator <span class="hljs-built_in">end</span> = content.<span class="hljs-built_in">end</span>();
    <span class="hljs-keyword">auto</span> count = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">std</span>::regex_search(start, <span class="hljs-built_in">end</span>, result, pattern, <span class="hljs-built_in">std</span>::regex_constants::match_any))
    {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> title = result[<span class="hljs-number">1</span>];
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> link = result[<span class="hljs-number">2</span>];
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> description = result[<span class="hljs-number">3</span>];
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> pubdate = result[<span class="hljs-number">4</span>];
        description = trim(description);

        NewsStory story;
        story.<span class="hljs-built_in">set</span>(title, link, description, pubdate);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">": "</span>&lt;&lt; story &lt;&lt; <span class="hljs-string">"\n"</span>;
        stories.push_back(story);

        start = result[<span class="hljs-number">0</span>].second;
        ++count;
    }

    <span class="hljs-keyword">return</span> stories;
}
</div></code></pre>
<p>仅需调用</p>
<pre class="hljs"><code><div>do_fetch(<span class="hljs-string">"http://www.chinanews.com/"</span>, <span class="hljs-string">"rss/scroll-news.xml"</span>);
</div></code></pre>
<p>就可以读取上面网址下面的内容。</p>
<h2 id="3-%E8%BF%87%E6%BB%A4">3 过滤</h2>
<h3 id="31-%E5%AF%B9%E4%BA%8E%E8%BF%87%E6%BB%A4%E7%9A%84%E8%80%83%E8%99%91">3.1 对于过滤的考虑</h3>
<p>用户的兴趣点各不相同，因此最好把用户的兴趣通过一个文件描述出来。例如</p>
<pre class="hljs"><code><div>// trigger file

// title trigger named t1
t1,TITLE,election
// description trigger named t2
t2,TITLE,中国
// description trigger named t3
t3,TITLE,暴雨
// after trigger named t4
t4,AFTER,2020-06-06 17:00:10
// composite trigger named t5
t5,AND,t2,t3
// composite trigger named t6
t6,AND,t1,t4
// the trigger list contains t5 and t6
ADD,t5,t6
</div></code></pre>
<p>在这个文件中，定义了t1,t2,t3,t4,t5,t6共6个过滤条件，其中t5和t6是通过AND复合的过滤条件。而最后的ADD语句则说明如果新闻满足t5或t6，则该新闻要用户需要关注的新闻。</p>
<h3 id="32-%E8%BF%87%E6%BB%A4%E7%9A%84%E8%AE%BE%E8%AE%A1">3.2 过滤的设计</h3>
<p>注意到过滤总是针对前面的NewsStory进行的，并且具有多种形式，可以考虑继承的形式实现，例如</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trigger</span>
{</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">doevaluate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NewsStory&amp;)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;

<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NewsStory&amp; story)</span>
    </span>{
        <span class="hljs-keyword">return</span> doevaluate(story);
    }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhraseTrigger</span>:</span> <span class="hljs-keyword">public</span> Trigger
{
<span class="hljs-keyword">public</span>:
    PhraseTrigger(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; phrase)
    : phrase_{phrase} 
    {}

<span class="hljs-keyword">protected</span>:
   <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_phrase_in</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; <span class="hljs-built_in">text</span>)</span> <span class="hljs-keyword">const</span></span>;

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">doevaluate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NewsStory&amp;)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> phrase_;
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TitleTrigger</span>:</span> <span class="hljs-keyword">public</span> PhraseTrigger
{
<span class="hljs-keyword">public</span>:
    TitleTrigger(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> phrase)
    : PhraseTrigger(phrase)
    {}
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">doevaluate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NewsStory&amp; story)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> is_phrase_in(story.Title());
    }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DescriptionTrigger</span>:</span> <span class="hljs-keyword">public</span> PhraseTrigger
{
<span class="hljs-keyword">public</span>:
    DescriptionTrigger(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> phrase)
    : PhraseTrigger(phrase)
    {}
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">doevaluate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NewsStory&amp; story)</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> is_phrase_in(story.Description());
    }
};

</div></code></pre>
<p>大家可以设计一下BeforeTrigger和AfterTrigger，以及NotTrigger, AndTrigger和OrTrigger的实现。</p>
<h3 id="33-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%A1%A8%E7%A4%BA%E6%89%80%E6%9C%89%E7%9A%84%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6">3.3 如何在内存中表示所有的过滤条件？</h3>
<p>回到3.1中，我们在解析文件时，需要把所有的命名的过滤条件都记录下来，可以使用一个map形式的数据，即</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, Trigger*&gt; triggers;
</div></code></pre>
<p>而把所有ADD后面的过滤条件放在一个列表TriggerList list中，以便使用。同时，我们定义函数</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">std</span>::istream&amp; <span class="hljs-title">read_trigger_config</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::istream&amp; is, TriggerList&amp; <span class="hljs-built_in">list</span>)</span></span>;
</div></code></pre>
<p>来解析triggers.txt文件。read_trigger_config的实现有一些难度，可以自己先自行设计一下。</p>
<h3 id="34-%E8%BF%87%E6%BB%A4">3.4 过滤</h3>
<p>过滤的过程非常简单，主体代码如下：</p>
<pre class="hljs"><code><div>    NewsStories stories = fetch();

    TriggerList triggers;
    <span class="hljs-built_in">std</span>::ifstream fs{<span class="hljs-string">"triggers.txt"</span>};
    read_trigger_config(fs, triggers);

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; story: stories){
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; ptrigger: triggers)
            <span class="hljs-keyword">if</span> (ptrigger-&gt;evaluate(story)){
                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; story &lt;&lt; <span class="hljs-string">"\n"</span>;
                <span class="hljs-keyword">break</span>;
            }
    }
</div></code></pre>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2>
<p>[1] 如何用RSS订阅？ https://zhuanlan.zhihu.com/p/64457116</p>
<p>[2] 中国新闻网。http://www.chinanews.com/rss/</p>
<p>[3] SFML的network功能。https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Http.php</p>
<p>[4] C++的re功能。https://en.cppreference.com/w/cpp/regex</p>

</body>
</html>
